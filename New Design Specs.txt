##### General Overview:
1. Central Etherpad Server (CES) starts up, begins listening for client requests to connect and create/edit pads
2. Client A begins connection to CES
3. CES sends back HTML page with Javascript code in required <script> tags in header, that will be an independent process
	running the "Client-Peer" A's code (within the client's browser as part of the HTML page's background)
	- This Javascript code is our written code, separated into another file in the etherpad file directory
	- Can also be a Go-to-Javascript compiled code
	- Also, we'll probably need to send this embedded Javascript code within the HTML page of the actual pad, not the 
		initial login/create-new-pad HTML page for incoming users
4. This Client-Peer A's code will periodically send heartbeats to CES to test its connection and see if CES has gone down
	- We are ignoring cases where only a single Client-Peer has disconnected from the server
		- Technically impossible to ignore, since Client-Peer A doesn't know if it's the only one that's disconnected
		- What we can do is that, based on some deterministic alphabetical ordering, if this Client-Peer A is the first
			one to host an open connection on, say, port 3000, then it should wait for incoming Client-Peers to connect
			to my port 3000, and if there is no one connecting within a timeout window, then I know either 1) I'm the only
			one disconnected, or 2) I cannot be reached by other peers anyways, and can handle either trivial case; otherwise,
			if some other Client-Peer B is supposed to be the first one to host an open connection on their port 3000, A
			tries to connect to their port directly, and either 1) A times out trying to reach B, at which point it should
			try C, or 2) A is rejected at B's port, at which point A immediately knows that B is still connected to the server
			-- at which point, what should A do...? (either continue to retry connecting to CES and not letting the client
			type on Etherpad's UI, or... somehow try to piggyback updates from B's connection to the server?)
	- CES, meanwhile in its broadcasted updates to the pad, should continue to send all the mergeset changes to the clients
		as well as all currently-participating clients' IP addresses.
		- How are we supposed to do this? Is there an exposed hook within Etherpad's code that allows for sending along
			client IP-addresses as well?
			--> I figured out how exactly to do this.
5. If CES goes down (as noted by each Client-Peer's code timing out on its tested connection with CES), and all Client-Peers 
	are now seeking to elect a leader amongst themselves, we have a deterministic process that the alphabetically-first 
	Client-Peer opens up some open port X and listens, while all other Client-Peers simultaneously attempt to connect to 
	that Client-Peer's port X; if it fails, then all move on to connecting to the next alphabetical Client-Peer as leader.
	- This is a placeholder "leader-election" for now, in order to get a framework of code written.
	- This initial timeout period should be large (like maybe 5 seconds), for a large enough granularity such that all 
		Client-Peers more-or-less decide to timeout at the same time and try to connect to the next Client-Peer in line 
		to become leader.
6. Once the leader has been established, each peer's HTML page now transitions to a new, crappy UI, and each user can begin
	typing again (couldn't type before in the old HTML page due to Etherpad's client-side built-in functionality once detecting
	that the connection has been lost -- or is this because of, once you restart CES in the terminal, it wipes the database?) -- 
	each of the mergeset changes the user types gets sent to the leader, and the leader broadcasts those changes after committing
	a serial order on the mergeset changes it receives from all Client-Peers' changes; ALSO, the leader should be able to 
	periodically persist these log changes to a locally-written database (look for details on how either Etherpad does it or try 
	our own way of local storage -- probably our own way, since Javascript can only store so much from within a browser) -- this
	is so that even if a client refreshes their HTML page, we can't guarantee that they can connect back again (since all those
	local Javascript variables and configurations and peer IP addresses were lost), but we CAN guarantee that their changes
	on the P2P network haven't been lost up until that point.
	- Need to look into how to prevent CES from wiping the database upon failure -- i.e., how does it detect that a DirtyDB has
		already been locally written on the host machine?
		- Well... what if, instead of worrying about wiping the database upon failure, once the P2P network re-connects with CES,
			they can commit their changes on a new pad with the identical name? From the user's POV, this looks identical to just
			re-committing recent changes to the pad to the original file within CES's persisted database.
	- What exactly should the UI look like? What should it allow a user/client to do?
		- Probably doesn't have to be anything fancy, just needs to A) display all the old contents of the pad as it was supposed
			to look before (good thing all highlighting/italics/bolding/coloring is just HTML tags that should already be 
			pre-processed into HTML by Etherpad's client-side functionality for us), B) allow for users to type/enter in new updates 
			(ONLY plaintext options, nothing fancy that Etherpad offers -- future work!), and also C) display incoming updates 
			(this is probably the most challenging thing, as we'd have to account for updating the cursor and line numbers and 
			overflow of single lines)
*		- Or is this where the "simulation of what should happen with print statements and randomly-generated, periodic 
			append/delete/change mergeset changes" comes in...?
	- What SHOULD the Client-Peer code do in the event of a refresh? Should we just not care to handle those cases, since by
		attempting to go that URL, it's attempting to connect to the server that isn't up anymore?
		- What if it CAN connect to the server? Ah, I guess whatever changes a re-connected follower (by refreshing their page)
			attempts to make to the original pad on CES and merging those results with the eventually-reconnected P2P network
			should ultimately be handled by Etherpad's built-in functionality and mergeset algorithm.
NEW	- What should the Client-Peer code do in the event of disconnecting from the leader? Lock out the user from changes in our
		crappy UI until it detects that it can re-connect again and receive the leader's changes in that interim period? And again,
		time-out eventually in that event and attempt its own leader-election?
NEW	- When should these persisted changes be read again? Because let's say everyone -- including the temporary leader -- accidentally
		refreshes and loses all mention/reference to this locally-cached persistent storage of all updates to the pad while the
		CES was down; how are those changes recovered?
		- What you could do... is when a client refreshes, and they try to reconnect to the main CES again, CES (now back online) will
			either send back the home HTML page (where the user enters in the name of the pad first) OR will just refresh to requesting
			from CES the actual original pad's HTML page (since they're refreshing to that same URL and Etherpad differentiates pads by
			URL). Thus, we need to modify the Client-Side code to be able to detect exactly when a pad arrives, and in that split instance,
			check (via HTML5's LocalStorage) that there aren't any locally-persisted storage objects with the key of this pad's URL or name,
			and if there is an object by that name, the Client-Side code immediately extracts it and manually adds to (or replaces?) all the 
			text in the original pad with those changes (can even have, in the interim, a lock-out mechanism that prevents the user from 
			typing until these changes have been applied, similar to what Etherpad does when the user disconnects); that way, by just
			changing the pad's contents as soon as we get it, the original client-side Etherpad code will submit those changes directly to
			CES and have those changes committed there.
			- https://www.w3schools.com/html/html5_webstorage.asp
			- https://www.smashingmagazine.com/2010/10/local-storage-and-how-to-use-it/#use-case-2-maintaining-the-state-of-an-interface-the-simple-way
			- http://blog.teamtreehouse.com/storing-data-on-the-client-with-localstorage
7. Meanwhile, in the background, each peer is attempting to re-connect to CES -- in the event that any follower is able to
	re-connect to CES, it notifies the leader. Once the leader discovers that CES is back up again (either by a notification
	from a follower or by its own background process), it immediately A) suspends the user from being able to write anymore, 
	B) sends all its recently-committed mergeset changes to all Client-Peers along with a notification that the P2P network should
	begin attempting to re-connect to CES, and C) immediately re-connecting to CES, writing all locally-persisted/committed changes
	to the pad in Etherpad's original UI (which wasn't allowed to be typed on during this disconnect with CES because of Etherpad's 
	built-in functionality; meanwhile, its HTML was just hidden this entire time from the user to accommodate our crappy UI), and 
	re-displaying this UI to the user-client so that they can continue typing again and committing changes to the original pad in CES. 
	This should be a free-for-all reaction between B) and C), since any such Client-Peer that re-connects to CES first gets to commit 
	all the mergeset changes they all share (along with any locally-buffered changes a Client-Peer follower's user made in before it 
	received the command from the leader to re-connect to CES); any Client-Peer that is unable to get the notification to re-connect 
	to CES in this time period would end up getting rejected from connecting to a port on the temporary-leader's machine, and thus 
	would then know that the server is back up and being handled like in #4.
	- Would it be easier to take all mergeset changes in the P2P phase and merge them into one overall change, before sending back all
		updates to the pad to CES?
	- Need to really understand the Mergeset Algorithm in any case
	
	
##### Caveats:
- Eventually need to implement a P2P leader-election process (probably with WebRTC) instead of a deterministic process like
	we're doing in Steps 4&5, we can't just decide to directly connect to one of our peers upon server-failure and let that
	leader automatically become the leader who commits/broadcasts all mergeset changes (that's not how the Raft lab code
	works and there's also consideration of a leader committing mergeset changes when it itself is behind)
- We have to figure out where exactly in Etherpad's code to turn on/off the inability for the user to type in the pad once
	it detects that the connection to CES has been lost
	- Or do we...? 
	- Maybe we just need to change the "Reconnecting" prompt to "Now establishing P2P editing"? Or just hide this entire original
		Etherpad UI in the background of the HTML page as our Javascript code just renders our new shitty UI on top of the old one?
	- Even if we do, I think there should be some exposed client-side hook events that might make this feasible?
- We need to also figure out, eventually, usage tests cases to demo for Appavoo
- This is all a plugin, so we need to figure out how to exactly modify the HTML page sent from CES to initially-connecting clients
	such that the require-script tags also send along the extra code files we have added to Etherpad's directory, as well as the hooks
	or events Etherpad exposes that allows us to obtain user IP-addresses, store them server-side, and broadcast them with each update
	we send to Client-Peers.
	- But wait, what is the current client-side Etherpad code that handles/processes these incoming updates from the server? We need to
		find the appropriate hooks/events our plug-in can implement such that we process these IP addresses ourselves in the client-side
		HTML page
		- It might look something like this: require-script tags inject our code with pre-written functions (including some "main()" 
			and even some asynchronous "heartbeat()" "background()" functions) into the HTML page, and the plug-in's implemented 
			client-side hooks both initially start this heartbeat() function and meanwhile somehow write/store/capture peers' IP addresses
			somewhere locally when handling client-side events that process new updates from the server; then, when the server fails,
			our plug-in's implemented client-side hooks will detect that through some event (need to find such an event, else this 
			failure-detection will have to be written in and carried out by the independent heartbeat() function running in the background)
			and then look for these peers' IP addresses (how do we store Javascript variables in global scope in the HTML page?), initiate
			the P2P connections/leader election, while meanwhile initiating the background() process to detect for CES's restart and also
			editing in real-time our crappy new UI placed on top of the old UI; then, we need to figure out how Javascript functions can
			asynchronously notify each other once the background() function notices CES has come back on; then the main() function has to
			initiate the transition process of editing the UI back to the original Etherpad UI, as well as actually re-connecting with CES
			and killing all background processes that were running in this P2P phase.
	
##### Alternate Ideas:
- Crate -- somehow turning Crate's P2P network into a central-server, Raft-election organized network, by first isolating a designated peer
	from incoming document changes from other peers, "updating" that peer's internal logic/instructions, then having that peer notify the others
	of the network's transition and becoming the centralized leader for the P2P network that receives all incoming document changes and commits 
	and broadcasts all changes outgoing to other peers in the new organization?
	
	
##### Useful Etherpad Documentation Resources:
https://github.com/ether/etherpad-lite/tree/develop/doc
https://github.com/ether/etherpad-lite/blob/develop/doc/api/editbar.md
https://github.com/ether/etherpad-lite/blob/develop/doc/api/editorInfo.md
https://github.com/ether/etherpad-lite/blob/develop/doc/api/embed_parameters.md
https://github.com/ether/etherpad-lite/blob/develop/doc/api/http_api.md
https://github.com/ether/etherpad-lite/blob/develop/doc/api/toolbar.md

https://github.com/ether/etherpad-lite/blob/develop/doc/database.md
https://github.com/ether/etherpad-lite/blob/develop/doc/easysync/easysync-full-description.pdf
https://github.com/ether/etherpad-lite/blob/develop/doc/easysync/easysync-notes.pdf
https://github.com/ether/etherpad-lite/blob/develop/doc/api/changeset_library.md


https://github.com/ether/etherpad-lite/wiki/Creating-a-plugin
https://github.com/ether/etherpad-lite/blob/develop/doc/plugins.md
https://www.npmjs.com/package/etherpad-pluginhelper
http://etherpad.org/doc/v1.5.7/#index_hooks
https://github.com/ether/etherpad-lite/blob/develop/doc/api/hooks_client-side.md
https://github.com/ether/etherpad-lite/blob/develop/doc/api/hooks_server-side.md

Potentially Useful Hooks (and file this function is located in):
aceEditEvent					src/static/js/ace2_inner.js, 
postAceInit & aceInitialized 	src/static/js/pad.js, 
userJoinOrUpdate 				src/static/js/pad_userlist.js, 
clientReady 					src/node/handler/PadMessageHandler.js, 
userLeave 						src/node/handler/PadMessageHandler.js, 
getLineHTMLForExport 			src/node/utils/ExportHtml.js, 
clientVars 						src/node/handler/PadMessageHandler.js, 
padUpdate 						src/node/db/Pad.js, 
handleMessage 					src/node/handler/PadMessageHandler.js



##### More Notes on Etherpad Code Organization
Oh that's interesting...
src/static/js/admin/settings.js
src/static/js/timeslider.js
src/static/js/admin/plugins.js
src/static/js/pad.js
	are the client-side files that begin the connection with the server (via the lines "io.connect(...)" or "socket.connect(...)"), and
src/node/handler/SocketIORouter.js
	is the handler on the server-side that ultimately receives these connection requests on the server-side, that hands off the connection 
	to another function called handleConnect() within PadMessageHandler.js (and also, all this sockets functionality is provided by some 
	fundamental 'socket.io' library (that's also present in the HTML pages), that's also listed in Etherpad's package.json as a dependency); 
	in SocketIORouter.js, it has some code that says:
		for(var i in components) {
			components[i].handleConnect(client);
		}
	where client was the passed in argument to the encapsulating function in "socket.sockets.on('connection', function(client) {...})"
	while components is a map that takes in a module (and its name) and does the following: "components[moduleName] = module;" -- therefore,
	if we take each of these client-side files to be a component, then each time a client connection request comes in on the server's socket,
	the "handleConnect()" function is called to register each of them (this function is found in src/node/handler/PadMessageHandler.js).
	Also, there are two more files that have similar "io.on('connection', function (socket) {...})" code -- that is:
		src/node/hooks/express/adminplugins.js
		src/node/hooks/express/adminsettings.js

		
ALSO, THIS FILE SEEMS EXTREMELY IMPORTANT AS CLIENT-SIDE CODE:
src/static/js/collab_client.js
	--> Furthermore, in here, is a function called handleMessageFromServer(), and it calls the hook "handleClientMessage_" + msg.type of the received
		message (along with that message's payload), which can be a "SERVER_MESSAGE" or "USER_LEAVE" or a "ACCEPT_COMMIT", etc.
		
		
##### More on SocketIO & Socket.io w/ Etherpad:
https://github.com/ether/etherpad-lite/blob/7ecf240d9e46ac41259100bf83242ca7b8fc205b/src/node/hooks/express/socketio.js
	has a line called "var socketio = require('socket.io');" which can be explained by
https://socket.io/docs/#
	and Etherpad uses the socketio var to consume the current application instance to create a server and listen on that server's open connections --
	this can help be explained by
http://stackoverflow.com/questions/33703546/difference-between-io-on-and-socket-on-in-socket-io
http://stackoverflow.com/questions/24266910/io-onconnection-vs-io-sockets-onconnection
http://stackoverflow.com/questions/13504320/socket-io-namespaces-channels-co
	while afterwards, it then gets the client object returned from socket.io and obtains its IP address (via setSocketIO()), as explained in
http://stackoverflow.com/questions/6458083/get-the-clients-ip-address-in-socket-io/25002414#25002414
http://stackoverflow.com/questions/6458083/get-the-clients-ip-address-in-socket-io/37474244#37474244
	and at which point it is ready to process that client's message (can be of various types, each different message processed by PadMessageHandler),
	and then calls addComponent() within SocketIORouter.js on a "pad" component (the name for the component linked back to the PadMessageHandler module).

https://github.com/ether/etherpad-lite/issues/1399
https://github.com/ether/etherpad-lite/blob/115f7d6b5124a75f32654eb45c8e0edd65863f4e/node/PadMessageHandler.js
https://github.com/ether/etherpad-lite/pull/1489
https://github.com/ether/etherpad-lite/commit/14e1f3bf222947401b78147764e889bb446893af
https://github.com/socketio/socket.io/blob/1f59e4526a9ff061512012cd47e65962ccd0e649/History.md
https://github.com/socketio/socket.io/blob/01a4623613d9791d1c2043f092c7c25d55c35279/lib/socket.js


##### How to Obtain & Broadcast IP Addresses from Server Code w/ Our Plugin
src/node/handler/SocketIORouter.js
	--> Can exploit lines 64-69 for later call within line 84's "client.on('message', function(message) {...})" 
		that later passes the "client" object through to the handleMessage() function, which is called in...
src/node/handler/PadMessageHandler.js
	--> ...that can then be used to modify/add messages via the exposed hook in lines 197-205 of PadMessageHandler,
		such that the client's IP address is gathered intermediately through the passed-in client object, stored in
		some global state of the plugin's, along with all the other IP addresses of all other clients in this pad,
		and depending on the type of the message received from the handleMessage() hook, we can also broadcast to the
		receiving clients all the other clients' IP-addresses for a particular pad. Also, beware of handling messages
		without first checking client authorization/access to a pad: 
			https://github.com/ether/etherpad-lite/blob/f91534d57a3cddcd46aa58358684695a969705c9/doc/api/hooks_server-side.md
			--> Getting IP address from client object can be done in multiple different ways through the Socket.io library
			
##### Possible Fixes to Injecting Client-Side Scripts
	Look at how the code in index.js for eejsBlock_scripts here
https://github.com/JohnMcLear/ep_offline_edit/blob/master/index.js
	injects the code found here
https://github.com/JohnMcLear/ep_offline_edit/blob/master/static/js/offline_edit.js
	as a variable with method functionality to be called like so when the ep.json seen here
https://github.com/JohnMcLear/ep_offline_edit/blob/master/ep.json
	registers a function for the exposed aceEditEvent hook that is explicitly exported/mentioned in here
https://github.com/JohnMcLear/ep_offline_edit/blob/master/static/js/aceEditEvent.js
	which relies on said variable with method functionality and calls its method .save() WITHIN the HTML page --
	I wonder if declaring those functions as a var with local scope within the HTML page made a difference?

Also, how he adds paths to the Express Server application in index.js via the expressCreateServer hook and also
the use of .appcache and ejs template files within the plug-in sent over to the application is a really good example
of how we might need to do so in the future (for our crappy UI):
	https://github.com/ether/etherpad-lite/blob/develop/doc/api/hooks_server-side.md#expresscreateserver
	https://expressjs.com/en/api.html#app.get
	***"HTML5 provides an application caching mechanism that lets web-based applications run offline."
	https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache
	
##### On Potential Issues from Merging Changesets via Etherpad's Algorithm?
Main Question: is the purpose of the timeslider object to prevent the case where a user writes X to the pad, then deletes X, 
and then before the delete can commit, the write on the server commits and then gets broadcasted back to the user and that
old, updated write overrules the later delete operation and puts X back into the user's pad? Read up:
	https://github.com/ether/etherpad-lite/blob/7ecf240d9e46ac41259100bf83242ca7b8fc205b/doc/easysync/easysync-full-description.pdf
	
	
	
	
	
	
##### Future Work/Considerations?
- Implementing security with the central server broadcasting all other clients' IPs for a given pad -- could be done by having a client
	initially receive an encrypted key-value store upon each new session with the central server (that the client could decrypt with a 
	key set-up phase in a similar process as Diffie-Hellman) containing Client-ID:IP-Address key:value pairs, and that as the central
	server continually broadcasts the most up-to-date ID:IP store along with each message for each client of a given pad, it uses the
	specific session it maintains with each client as the seed to encrypt that store uniquely, and sends along each session-specific
	encrypted store to the corresponding client with that session; then, when broadcasting mentions of specific clients to other clients,
	the client can use its session-specific key-value store and the ID to simply, if needed, find out which IP address that client's ID
	corresponds to (and do whatever it needs to with that specific client's IP address); this is all in consideration of Etherpad sending
	data across HTTP vs. HTTPS, or to somehow defend against anyone not within that group of clients somehow posing as one of the IP addresses.
	Also, because we assume our plug-in is not scalable, this assumption helps circumvent any concerns of overloading a server/network due
	to the constant broadcasting of a large number of IP addresses in the key-value store, that would then require a more scalable method of
	peer IP-address discovery through something like distributed hash-tables/peer-lists commonly found in more fully-fledged P2P applications.
	- Cannot ultimately be more secure than any other P2P application: https://en.wikipedia.org/wiki/Peer-to-peer#Security_and_trust
- See the "Future Work" section of the Chord paper for more ideas
	