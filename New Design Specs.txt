##### General Overview:
1. Central Etherpad Server (CES) starts up, begins listening for client requests to connect and create/edit pads
2. Client A begins connection to CES
3. CES sends back HTML page with Javascript code in required <script> tags in header, that will be an independent process
	running the "Client-Peer" A's code (within the client's browser as part of the HTML page's background)
	- This Javascript code is our written code, separated into another file in the etherpad file directory
	- Can also be a Go-to-Javascript compiled code
	- Also, we'll probably need to send this embedded Javascript code within the HTML page of the actual pad, not the 
		initial login/create-new-pad HTML page for incoming users
4. This Client-Peer A's code will periodically send heartbeats to CES to test its connection and see if CES has gone down
	- We are ignoring cases where only a single Client-Peer has disconnected from the server
		- Technically impossible to ignore, since Client-Peer A doesn't know if it's the only one that's disconnected
		- What we can do is that, based on some deterministic alphabetical ordering, if this Client-Peer A is the first
			one to host an open connection on, say, port 3000, then it should wait for incoming Client-Peers to connect
			to my port 3000, and if there is no one connecting within a timeout window, then I know either 1) I'm the only
			one disconnected, or 2) I cannot be reached by other peers anyways, and can handle either trivial case; otherwise,
			if some other Client-Peer B is supposed to be the first one to host an open connection on their port 3000, A
			tries to connect to their port directly, and either 1) A times out trying to reach B, at which point it should
			try C, or 2) A is rejected at B's port, at which point A immediately knows that B is still connected to the server
			-- at which point, what should A do...? (either continue to retry connecting to CES and not letting the client
			type on Etherpad's UI, or... somehow try to piggyback updates from B's connection to the server?)
	- CES, meanwhile in its broadcasted updates to the pad, should continue to send all the mergeset changes to the clients
		as well as all currently-participating clients' IP addresses.
		- How are we supposed to do this? Is there an exposed hook within Etherpad's code that allows for sending along
			client IP-addresses as well?
5. If CES goes down (as noted by each Client-Peer's code timing out on its tested connection with CES), and all Client-Peers 
	are now seeking to elect a leader amongst themselves, we have a deterministic process that the alphabetically-first 
	Client-Peer opens up some open port X and listens, while all other Client-Peers simultaneously attempt to connect to 
	that Client-Peer's port X; if it fails, then all move on to connecting to the next alphabetical Client-Peer as leader.
	- This is a placeholder "leader-election" for now, in order to get a framework of code written.
	- This initial timeout period should be large (like maybe 5 seconds), for a large enough granularity such that all 
		Client-Peers more-or-less decide to timeout at the same time and try to connect to the next Client-Peer in line 
		to become leader.
6. Once the leader has been established, each peer's HTML page now transitions to a new, crappy UI, and each user can begin
	typing again (couldn't type before in the old HTML page due to Etherpad's client-side built-in functionality once detecting
	that the connection has been lost -- or is this because of, once you restart CES in the terminal, it wipes the database?) -- 
	each of the mergeset changes the user types gets sent to the leader, and the leader broadcasts those changes after committing
	a serial order on the mergeset changes it receives from all Client-Peers' changes; ALSO, the leader should be able to 
	periodically persist these log changes to a locally-written database (look for details on how either Etherpad does it or try 
	our own way of local storage -- probably our own way, since Javascript can only store so much from within a browser) -- this
	is so that even if a client refreshes their HTML page, we can't guarantee that they can connect back again (since all those
	local Javascript variables and configurations and peer IP addresses were lost), but we CAN guarantee that their changes
	on the P2P network haven't been lost up until that point.
	- Need to look into how to prevent CES from wiping the database upon failure -- i.e., how does it detect that a DirtyDB has
		already been locally written on the host machine?
		- Well... what if, instead of worrying about wiping the database upon failure, once the P2P network re-connects with CES,
			they can commit their changes on a new pad with the identical name? From the user's POV, this looks identical to just
			re-committing recent changes to the pad to the original file within CES's persisted database.
	- What exactly should the UI look like? What should it allow a user/client to do?
		- Probably doesn't have to be anything fancy, just needs to A) display all the old contents of the pad as it was supposed
			to look before (good thing all highlighting/italics/bolding/coloring is just HTML tags that should already be 
			pre-processed into HTML by Etherpad's client-side functionality for us), B) allow for users to type/enter in new updates 
			(ONLY plaintext options, nothing fancy that Etherpad offers -- future work!), and also C) display incoming updates 
			(this is probably the most challenging thing, as we'd have to account for updating the cursor and line numbers and 
			overflow of single lines)
*		- Or is this where the "simulation of what should happen with print statements and randomly-generated, periodic 
			append/delete/change mergeset changes" comes in...?
	- What SHOULD the Client-Peer code do in the event of a refresh? Should we just not care to handle those cases, since by
		attempting to go that URL, it's attempting to connect to the server that isn't up anymore?
		- What if it CAN connect to the server? Ah, I guess whatever changes a re-connected follower (by refreshing their page)
			attempts to make to the original pad on CES and merging those results with the eventually-reconnected P2P network
			should ultimately be handled by Etherpad's built-in functionality and mergeset algorithm.
7. Meanwhile, in the background, each peer is attempting to re-connect to CES -- in the event that any follower is able to
	re-connect to CES, it notifies the leader. Once the leader discovers that CES is back up again (either by a notification
	from a follower or by its own background process), it immediately A) suspends the user from being able to write anymore, 
	B) sends all its recently-committed mergeset changes to all Client-Peers along with a notification that the P2P network should
	begin attempting to re-connect to CES, and C) immediately re-connecting to CES, writing all locally-persisted/committed changes
	to the pad in Etherpad's original UI (which wasn't allowed to be typed on during this disconnect with CES because of Etherpad's 
	built-in functionality; meanwhile, its HTML was just hidden this entire time from the user to accommodate our crappy UI), and 
	re-displaying this UI to the user-client so that they can continue typing again and committing changes to the original pad in CES. 
	This should be a free-for-all reaction between B) and C), since any such Client-Peer that re-connects to CES first gets to commit 
	all the mergeset changes they all share (along with any locally-buffered changes a Client-Peer follower's user made in before it 
	received the command from the leader to re-connect to CES); any Client-Peer that is unable to get the notification to re-connect 
	to CES in this time period would end up getting rejected from connecting to a port on the temporary-leader's machine, and thus 
	would then know that the server is back up and being handled like in #4.
	- Would it be easier to take all mergeset changes in the P2P phase and merge them into one overall change, before sending back all
		updates to the pad to CES?
	- Need to really understand the Mergeset Algorithm in any case
	
	
##### Caveats:
- Eventually need to implement a P2P leader-election process (probably with WebRTC) instead of a deterministic process like
	we're doing in Steps 4&5, we can't just decide to directly connect to one of our peers upon server-failure and let that
	leader automatically become the leader who commits/broadcasts all mergeset changes (that's not how the Raft lab code
	works and there's also consideration of a leader committing mergeset changes when it itself is behind)
- We have to figure out where exactly in Etherpad's code to turn on/off the inability for the user to type in the pad once
	it detects that the connection to CES has been lost
	- Or do we...? 
	- Maybe we just need to change the "Reconnecting" prompt to "Now establishing P2P editing"? Or just hide this entire original
		Etherpad UI in the background of the HTML page as our Javascript code just renders our new shitty UI on top of the old one?
	- Even if we do, I think there should be some exposed client-side hook events that might make this feasible?
- We need to also figure out, eventually, usage tests cases to demo for Appavoo
- This is all a plugin, so we need to figure out how to exactly modify the HTML page sent from CES to initially-connecting clients
	such that the require-script tags also send along the extra code files we have added to Etherpad's directory, as well as the hooks
	or events Etherpad exposes that allows us to obtain user IP-addresses, store them server-side, and broadcast them with each update
	we send to Client-Peers.
	- But wait, what is the current client-side Etherpad code that handles/processes these incoming updates from the server? We need to
		find the appropriate hooks/events our plug-in can implement such that we process these IP addresses ourselves in the client-side
		HTML page
		- It might look something like this: require-script tags inject our code with pre-written functions (including some "main()" 
			and even some asynchronous "heartbeat()" "background()" functions) into the HTML page, and the plug-in's implemented 
			client-side hooks both initially start this heartbeat() function and meanwhile somehow write/store/capture peers' IP addresses
			somewhere locally when handling client-side events that process new updates from the server; then, when the server fails,
			our plug-in's implemented client-side hooks will detect that through some event (need to find such an event, else this 
			failure-detection will have to be written in and carried out by the independent heartbeat() function running in the background)
			and then look for these peers' IP addresses (how do we store Javascript variables in global scope in the HTML page?), initiate
			the P2P connections/leader election, while meanwhile initiating the background() process to detect for CES's restart and also
			editing in real-time our crappy new UI placed on top of the old UI; then, we need to figure out how Javascript functions can
			asynchronously notify each other once the background() function notices CES has come back on; then the main() function has to
			initiate the transition process of editing the UI back to the original Etherpad UI, as well as actually re-connecting with CES
			and killing all background processes that were running in this P2P phase.
	
##### Alternate Ideas:
- Crate -- somehow turning Crate's P2P network into a central-server, Raft-election organized network, by first isolating a designated peer
	from incoming document changes from other peers, "updating" that peer's internal logic/instructions, then having that peer notify the others
	of the network's transition and becoming the centralized leader for the P2P network that receives all incoming document changes and commits 
	and broadcasts all changes outgoing to other peers in the new organization?
	
	
##### Useful Etherpad Documentation Resources:
https://github.com/ether/etherpad-lite/tree/develop/doc
https://github.com/ether/etherpad-lite/blob/develop/doc/api/editbar.md
https://github.com/ether/etherpad-lite/blob/develop/doc/api/editorInfo.md
https://github.com/ether/etherpad-lite/blob/develop/doc/api/embed_parameters.md
https://github.com/ether/etherpad-lite/blob/develop/doc/api/http_api.md
https://github.com/ether/etherpad-lite/blob/develop/doc/api/toolbar.md

https://github.com/ether/etherpad-lite/blob/develop/doc/database.md
https://github.com/ether/etherpad-lite/blob/develop/doc/easysync/easysync-full-description.pdf
https://github.com/ether/etherpad-lite/blob/develop/doc/easysync/easysync-notes.pdf
https://github.com/ether/etherpad-lite/blob/develop/doc/api/changeset_library.md

https://github.com/ether/etherpad-lite/blob/develop/doc/plugins.md
https://www.npmjs.com/package/etherpad-pluginhelper
http://etherpad.org/doc/v1.5.7/#index_hooks
https://github.com/ether/etherpad-lite/blob/develop/doc/api/hooks_client-side.md
https://github.com/ether/etherpad-lite/blob/develop/doc/api/hooks_server-side.md
Potentially Useful Hooks (and file this function is located in):
aceEditEvent					src/static/js/ace2_inner.js, 
postAceInit & aceInitialized 	src/static/js/pad.js, 
userJoinOrUpdate 				src/static/js/pad_userlist.js, 
clientReady 					src/node/handler/PadMessageHandler.js, 
userLeave 						src/node/handler/PadMessageHandler.js, 
getLineHTMLForExport 			src/node/utils/ExportHtml.js, 
clientVars 						src/node/handler/PadMessageHandler.js, 
padUpdate 						src/node/db/Pad.js, 
handleMessage 					src/node/handler/PadMessageHandler.js