##### NEW Tasks #####
1. See Old Tasks #1

2. Figure out how to install y-js modules with bower and accurately include them in script tag when injecting #1: https://bower.io/

4. See Old Tasks #4, but solely for purposes of reaching central Etherpad server like in Old Tasks #13

5. See Old Tasks #5, and also must understand details of y-js paper and algorithm for presentation (see linked paper)

6. Like Old Tasks #7, except we have to figure out how to reach consensus on WebRTC "room" name (just our plug-in name + padID + something else?)

7. Like Old Tasks #9, except we have to figure out how to use y-js's textarea bindings and create our own "crappy" UI

8. Similar to Old Tasks #11, except we'd need to figure out when (and in what format) to persist changes, as it doesn't seem y-js helps with that;
	would be extremely helpful and very important in understanding how ep_offline_edit actually saves and loads the HTML of Etherpad for temporary
	editing; how does his code detect when the client-side code has disconnected from Etherpad???

9. See Old Tasks #12, essentially have client-side code detect that there's persisted changes for a pad before letting user type again

10. Similar to Old Tasks #14, except when any one client detects server is back up, must figure out how to notify all other clients, lock out
	the user from typing, change to Etherpad's original UI and erase the old UI, and apply the recently-persisted changes to Etherpad's original
	UI such that the server can receive all updates since it went down and commit them
	
11. Similar to Old Tasks #15, except the only logic to add is simply if client-peer can't connect to SimpleWebRTC room, lock user out from typing
	in our y-js UI until it can either contact the server or connect back into the room
	
12. Simple task, just figure out how to configure a settings.json for the plug-in so that people can specify a URL for the signal channel of WebRTC
	(see https://github.com/y-js/y-webrtc/blob/master/src/WebRTC.js at line 18, and https://www.html5rocks.com/en/tutorials/webrtc/infrastructure/ 
	and also WebRTC links)


https://github.com/y-js/yjs
http://y-js.org/
https://github.com/y-js/yjs/blob/master/README.md
http://y-js.org/#!/tutorial
https://github.com/y-js/y-webrtc
https://github.com/y-js/y-memory
https://github.com/y-js/y-text
http://y-js.org/#!/modules
http://dbis.rwth-aachen.de/~derntl/papers/preprints/icwe2015-preprint.pdf

--> y-js ACE != Etherpad's ACE: 
	https://groups.google.com/forum/#!topic/etherpad-lite-dev/0uU_LXp_iPg
	https://ace.c9.io/
--> How WebRTC works & establishes P2P: 
	https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API
	http://www.innoarchitech.com/what-is-webrtc-and-how-does-it-work/
	http://stackoverflow.com/questions/12708252/how-does-webrtc-work
	https://hacks.mozilla.org/2013/07/webrtc-and-the-ocean-of-acronyms/
	https://www.html5rocks.com/en/tutorials/webrtc/infrastructure/
	https://github.com/andyet/SimpleWebRTC
	https://simplewebrtc.com/
	https://github.com/dmonad/signalmaster
--> Further examples/papers on P2P and collaborative editing:
	https://hal.archives-ouvertes.fr/inria-00108523/document
	https://hal.archives-ouvertes.fr/inria-00336191/document
	https://github.com/bit/ep_webrtc



##### OLD Tasks #####
1. Etherpad plug-in skeleton that can inject client-side code into HTML page of pad before sending to Client
Done by Aditi

2. Central Server broadcasting IP addresses of all participating clients of pad along with every message to client (as well as modifying each 
	client's code also handling message to store IP address received)
Done by David - receiving IP addresses left

3. Figure out if Etherpad code prevents the scenario where a write of "Hello", then delete "Hello" by Client A gets sent to server, server only 
	sees first write of "Hello", sends back update to A, and committed update from server overwrites A's second operation of delete "Hello" 
	(does timeslider.js prevent this?)
Aditi
	
4. Figure out how to spin up a background-process within client-side code in HTML page to periodically check if it can reach an IP address
	(also, how to connect Task #1 to actually CALL and start this background-process)
Youcan

5. Figure out test scenarios for presentation's demo to Appavoo, to show that our plug-in adds fault-tolerance

6. How to directly send messages to client-peers (on which socket?) if you know their IP address
Aditi

7. Given #4 and #6, how to have client-code contact other peers to reach consensus if central Etherpad server is down
Dong

8. How to implement Raft leader election in client-side code (purpose of Raft leader-election is just to prevent split-brain)

9. How to "lock-out" client from typing when detects server is down, change all of Etherpad's UI in HTML to having a display:none CSS attribute,
	and then transitioning to our "crappy" UI
	
10. Deciding what our "crappy" UI is -- is it a simulation (console.log statements and randomly-generated, periodic append/delete/update changes)
	or is it actually a UI that allows users to A) see old document with fancy highlighting/italics/coloring/etc. like it was before, B) type in
	new changes in ONLY plaintext and send out changes, and C) actually see/apply incoming changes -- and implementing that UI
David	

11. Have client-side code "persist" each of its own changes and most-current document periodically using HTML5 local-storage

12. Modify client-side code to detect, upon receipt of (first?) update or HTML page of pad from central Etherpad server, whether there are locally
	persisted changes in HTML5 local-storage, then if there ARE local-changes, locking out the user from typing, applying those changes to the document
	(so that the server gets these last updates) and then deleting those local-storage updates and letting the client type again
	- Need to be careful with specific corner cases here...? Update cursor and line numbers upon applying other peers' changes if we do implement UI
	- Also need to detect, via follower's client-side code, whether leader has disconnected and given up control (to either another leader or server);
		see #15 for more details
	
13. Given #4, when in temporary P2P Raft-network, have every client periodically detect whether server is back up again

14. Given #13, implement transitioning to central Etherpad server again: if follower hears first, tell leader; when leader hears, lock-out user from
	typing and broadcast to all followers that server has come back; when followers hear server is back online, also lock-out user from typing; have
	all clients attempt to re-connect to central Etherpad server, and upon connection, transition back to original Etherpad UI by adding display:none
	CSS attribute to our temporary "crappy" UI, removing display:none attribute from original Etherpad UI in background, and doing the same as #12
	- As well, shutting off P2P connection (on ports?) of each temporary leader-client from receiving updates from disconnected returning followers
	
15. Figure out what to do in the event a follower disconnects from leader -- lock-out user from typing and message other peers to see if they can reach
	leader, and A) if they can, wait until can connect to leader, or B) if they can't, wait until timeout to attempt new Raft leader election? Until new
	leader can be established, client is locked out from typing; old leader can continue to type regardless -- if it detects new leader is elected, all
	changes are sent to new leader, but now new "precedence" from POV of old leader is established, in that if disconnected from new leader, now lock
	out client from typing -- this makes it so that at any given point, only 2 partitions can continue to type, but if at any point one partition can
	contact the other, the notification of recent leader will cascade and allow old partition to merge changes with other partition's changes (which can
	do no worse than original Etherpad server given that 1. their mergeset algorithm works such that if it receives two changes A & B, the resulting 
	document C must be the same as though it applied A-->B AND B-->A, and 2. we should have a reasonable amount of expectation that clients should adapt
	their behavior of adding/deleting/updating to a document in real-time)
	--> If we do implement our own UI in #10, should we allow notifications to users (like adding HTML <div>'s in real-time) to let them know if they've
		disconnected from the leader/if they are the leader committing changes? Or is that something to be discussed in "Future Work"?
